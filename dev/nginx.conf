worker_processes  10;

events {
  worker_connections  1024;
}

error_log /dev/stdout notice;

env MEMCACHED_HOST;
env MEMCACHED_PORT;

http {
  include       mime.types;
  default_type  application/octet-stream;

  lua_shared_dict counters 1m;
  lua_shared_dict decision_cache 1m;
  lua_shared_dict decision_cache_memc 1m;

  keepalive_timeout  65;

  # Docker embedded DNS resolver IP is hardcoded:
  # https://github.com/moby/libnetwork/blob/d0951081b35fa4216fc4f0064bf065beeb55a74b/sandbox.go#L136.
  # So hardcoding here is not a problem.
  resolver 127.0.0.11;

  server {
    listen       8080;
    server_name  localhost;

    location / {
      rewrite_by_lua_block {
        local global_throttle = require("resty.global_throttle")
        local my_throttle, err = global_throttle.new(10, 2,  ngx.shared.decision_cache, { provider = "shared_dict", name = "counters" })

        local key = ngx.req.get_uri_args()['key']
        local limit_exceeding = my_throttle:process(key)
        if limit_exceeding then
          return ngx.exit(429)
        end
      }

      content_by_lua_block {
        ngx.say("Halo!")
      }

    }

    location /memc {
      rewrite_by_lua_block {
        local global_throttle = require("resty.global_throttle")
        local my_throttle, err = global_throttle.new(10, 2,  ngx.shared.decision_cache_memc, {
          provider = "memcached",
          host = os.getenv("MEMCACHED_HOST"),
          port = os.getenv("MEMCACHED_PORT"),
          max_idle_timeout = 10000,
          pool_size = 100,
        })

        local key = ngx.req.get_uri_args()['key']
        local limit_exceeding = my_throttle:process(key)
        if limit_exceeding then
          return ngx.exit(429)
        end
      }

      content_by_lua_block {
        ngx.say("Halo!")
      }

    }

  }
}
